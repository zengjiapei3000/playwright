/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is generated by generate_channels.js, do not edit manually.

import { EventEmitter } from 'events';

export type Binary = string;

export interface Channel extends EventEmitter {
}

export type Metadata = {
  stack?: string,
};

export type Point = {
  x: number,
  y: number,
};

export type Rect = {
  x: number,
  y: number,
  width: number,
  height: number,
};

export type SerializedValue = {
  n?: number,
  b?: boolean,
  s?: string,
  v?: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0',
  d?: string,
  r?: {
    p: string,
    f: string,
  },
  a?: SerializedValue[],
  o?: {
    k: string,
    v: SerializedValue,
  }[],
  h?: number,
};

export type SerializedArgument = {
  value: SerializedValue,
  handles: Channel[],
};

export type AXNode = {
  role: string,
  name: string,
  valueString?: string,
  valueNumber?: number,
  description?: string,
  keyshortcuts?: string,
  roledescription?: string,
  valuetext?: string,
  disabled?: boolean,
  expanded?: boolean,
  focused?: boolean,
  modal?: boolean,
  multiline?: boolean,
  multiselectable?: boolean,
  readonly?: boolean,
  required?: boolean,
  selected?: boolean,
  checked?: 'checked' | 'unchecked' | 'mixed',
  pressed?: 'pressed' | 'released' | 'mixed',
  level?: number,
  valuemin?: number,
  valuemax?: number,
  autocomplete?: string,
  haspopup?: string,
  invalid?: string,
  orientation?: string,
  children?: AXNode[],
};

export type SetNetworkCookie = {
  name: string,
  value: string,
  url?: string,
  domain?: string,
  path?: string,
  expires?: number,
  httpOnly?: boolean,
  secure?: boolean,
  sameSite?: 'Strict' | 'Lax' | 'None',
};

export type NetworkCookie = {
  name: string,
  value: string,
  domain: string,
  path: string,
  expires: number,
  httpOnly: boolean,
  secure: boolean,
  sameSite: 'Strict' | 'Lax' | 'None',
};

export type NameValue = {
  name: string,
  value: string,
};

export type OriginStorage = {
  origin: string,
  localStorage: NameValue[],
};

export type SerializedError = {
  error?: {
    message: string,
    name: string,
    stack?: string,
  },
  value?: SerializedValue,
};

// ----------- Playwright -----------
export type PlaywrightInitializer = {
  chromium: BrowserTypeChannel,
  firefox: BrowserTypeChannel,
  webkit: BrowserTypeChannel,
  android: AndroidChannel,
  electron: ElectronChannel,
  deviceDescriptors: {
    name: string,
    descriptor: {
      userAgent: string,
      viewport: {
        width: number,
        height: number,
      },
      deviceScaleFactor: number,
      isMobile: boolean,
      hasTouch: boolean,
      defaultBrowserType: 'chromium' | 'firefox' | 'webkit',
    },
  }[],
  selectors: SelectorsChannel,
};
export interface PlaywrightChannel extends Channel {
}

// ----------- RemoteBrowser -----------
export type RemoteBrowserInitializer = {
  browser: BrowserChannel,
  selectors: SelectorsChannel,
};
export interface RemoteBrowserChannel extends Channel {
  on(event: 'video', callback: (params: RemoteBrowserVideoEvent) => void): this;
}
export type RemoteBrowserVideoEvent = {
  context: BrowserContextChannel,
  stream: StreamChannel,
  relativePath: string,
};

// ----------- Selectors -----------
export type SelectorsInitializer = {};
export interface SelectorsChannel extends Channel {
  register(params: SelectorsRegisterParams, metadata?: Metadata): Promise<SelectorsRegisterResult>;
}
export type SelectorsRegisterParams = {
  name: string,
  source: string,
  contentScript?: boolean,
};
export type SelectorsRegisterOptions = {
  contentScript?: boolean,
};
export type SelectorsRegisterResult = void;

// ----------- BrowserType -----------
export type BrowserTypeInitializer = {
  executablePath: string,
  name: string,
};
export interface BrowserTypeChannel extends Channel {
  launch(params: BrowserTypeLaunchParams, metadata?: Metadata): Promise<BrowserTypeLaunchResult>;
  launchPersistentContext(params: BrowserTypeLaunchPersistentContextParams, metadata?: Metadata): Promise<BrowserTypeLaunchPersistentContextResult>;
}
export type BrowserTypeLaunchParams = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  firefoxUserPrefs?: any,
  chromiumSandbox?: boolean,
  slowMo?: number,
};
export type BrowserTypeLaunchOptions = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  firefoxUserPrefs?: any,
  chromiumSandbox?: boolean,
  slowMo?: number,
};
export type BrowserTypeLaunchResult = {
  browser: BrowserChannel,
};
export type BrowserTypeLaunchPersistentContextParams = {
  userDataDir: string,
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  chromiumSandbox?: boolean,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'light' | 'dark' | 'no-preference',
  acceptDownloads?: boolean,
  _traceResourcesPath?: string,
  _tracePath?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
};
export type BrowserTypeLaunchPersistentContextOptions = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: NameValue[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  chromiumSandbox?: boolean,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'light' | 'dark' | 'no-preference',
  acceptDownloads?: boolean,
  _traceResourcesPath?: string,
  _tracePath?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
};
export type BrowserTypeLaunchPersistentContextResult = {
  context: BrowserContextChannel,
};

// ----------- Browser -----------
export type BrowserInitializer = {
  version: string,
  name: string,
};
export interface BrowserChannel extends Channel {
  on(event: 'close', callback: (params: BrowserCloseEvent) => void): this;
  close(params?: BrowserCloseParams, metadata?: Metadata): Promise<BrowserCloseResult>;
  newContext(params: BrowserNewContextParams, metadata?: Metadata): Promise<BrowserNewContextResult>;
  crNewBrowserCDPSession(params?: BrowserCrNewBrowserCDPSessionParams, metadata?: Metadata): Promise<BrowserCrNewBrowserCDPSessionResult>;
  crStartTracing(params: BrowserCrStartTracingParams, metadata?: Metadata): Promise<BrowserCrStartTracingResult>;
  crStopTracing(params?: BrowserCrStopTracingParams, metadata?: Metadata): Promise<BrowserCrStopTracingResult>;
}
export type BrowserCloseEvent = {};
export type BrowserCloseParams = {};
export type BrowserCloseOptions = {};
export type BrowserCloseResult = void;
export type BrowserNewContextParams = {
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceResourcesPath?: string,
  _tracePath?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  storageState?: {
    cookies?: SetNetworkCookie[],
    origins?: OriginStorage[],
  },
};
export type BrowserNewContextOptions = {
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceResourcesPath?: string,
  _tracePath?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  storageState?: {
    cookies?: SetNetworkCookie[],
    origins?: OriginStorage[],
  },
};
export type BrowserNewContextResult = {
  context: BrowserContextChannel,
};
export type BrowserCrNewBrowserCDPSessionParams = {};
export type BrowserCrNewBrowserCDPSessionOptions = {};
export type BrowserCrNewBrowserCDPSessionResult = {
  session: CDPSessionChannel,
};
export type BrowserCrStartTracingParams = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingOptions = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingResult = void;
export type BrowserCrStopTracingParams = {};
export type BrowserCrStopTracingOptions = {};
export type BrowserCrStopTracingResult = {
  binary: Binary,
};

// ----------- BrowserContext -----------
export type BrowserContextInitializer = {
  browserName: string,
};
export interface BrowserContextChannel extends Channel {
  on(event: 'bindingCall', callback: (params: BrowserContextBindingCallEvent) => void): this;
  on(event: 'close', callback: (params: BrowserContextCloseEvent) => void): this;
  on(event: 'page', callback: (params: BrowserContextPageEvent) => void): this;
  on(event: 'route', callback: (params: BrowserContextRouteEvent) => void): this;
  on(event: 'crBackgroundPage', callback: (params: BrowserContextCrBackgroundPageEvent) => void): this;
  on(event: 'crServiceWorker', callback: (params: BrowserContextCrServiceWorkerEvent) => void): this;
  addCookies(params: BrowserContextAddCookiesParams, metadata?: Metadata): Promise<BrowserContextAddCookiesResult>;
  addInitScript(params: BrowserContextAddInitScriptParams, metadata?: Metadata): Promise<BrowserContextAddInitScriptResult>;
  clearCookies(params?: BrowserContextClearCookiesParams, metadata?: Metadata): Promise<BrowserContextClearCookiesResult>;
  clearPermissions(params?: BrowserContextClearPermissionsParams, metadata?: Metadata): Promise<BrowserContextClearPermissionsResult>;
  close(params?: BrowserContextCloseParams, metadata?: Metadata): Promise<BrowserContextCloseResult>;
  cookies(params: BrowserContextCookiesParams, metadata?: Metadata): Promise<BrowserContextCookiesResult>;
  exposeBinding(params: BrowserContextExposeBindingParams, metadata?: Metadata): Promise<BrowserContextExposeBindingResult>;
  grantPermissions(params: BrowserContextGrantPermissionsParams, metadata?: Metadata): Promise<BrowserContextGrantPermissionsResult>;
  newPage(params?: BrowserContextNewPageParams, metadata?: Metadata): Promise<BrowserContextNewPageResult>;
  setDefaultNavigationTimeoutNoReply(params: BrowserContextSetDefaultNavigationTimeoutNoReplyParams, metadata?: Metadata): Promise<BrowserContextSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(params: BrowserContextSetDefaultTimeoutNoReplyParams, metadata?: Metadata): Promise<BrowserContextSetDefaultTimeoutNoReplyResult>;
  setExtraHTTPHeaders(params: BrowserContextSetExtraHTTPHeadersParams, metadata?: Metadata): Promise<BrowserContextSetExtraHTTPHeadersResult>;
  setGeolocation(params: BrowserContextSetGeolocationParams, metadata?: Metadata): Promise<BrowserContextSetGeolocationResult>;
  setHTTPCredentials(params: BrowserContextSetHTTPCredentialsParams, metadata?: Metadata): Promise<BrowserContextSetHTTPCredentialsResult>;
  setNetworkInterceptionEnabled(params: BrowserContextSetNetworkInterceptionEnabledParams, metadata?: Metadata): Promise<BrowserContextSetNetworkInterceptionEnabledResult>;
  setOffline(params: BrowserContextSetOfflineParams, metadata?: Metadata): Promise<BrowserContextSetOfflineResult>;
  storageState(params?: BrowserContextStorageStateParams, metadata?: Metadata): Promise<BrowserContextStorageStateResult>;
  crNewCDPSession(params: BrowserContextCrNewCDPSessionParams, metadata?: Metadata): Promise<BrowserContextCrNewCDPSessionResult>;
}
export type BrowserContextBindingCallEvent = {
  binding: BindingCallChannel,
};
export type BrowserContextCloseEvent = {};
export type BrowserContextPageEvent = {
  page: PageChannel,
};
export type BrowserContextRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type BrowserContextCrBackgroundPageEvent = {
  page: PageChannel,
};
export type BrowserContextCrServiceWorkerEvent = {
  worker: WorkerChannel,
};
export type BrowserContextAddCookiesParams = {
  cookies: SetNetworkCookie[],
};
export type BrowserContextAddCookiesOptions = {

};
export type BrowserContextAddCookiesResult = void;
export type BrowserContextAddInitScriptParams = {
  source: string,
};
export type BrowserContextAddInitScriptOptions = {

};
export type BrowserContextAddInitScriptResult = void;
export type BrowserContextClearCookiesParams = {};
export type BrowserContextClearCookiesOptions = {};
export type BrowserContextClearCookiesResult = void;
export type BrowserContextClearPermissionsParams = {};
export type BrowserContextClearPermissionsOptions = {};
export type BrowserContextClearPermissionsResult = void;
export type BrowserContextCloseParams = {};
export type BrowserContextCloseOptions = {};
export type BrowserContextCloseResult = void;
export type BrowserContextCookiesParams = {
  urls: string[],
};
export type BrowserContextCookiesOptions = {

};
export type BrowserContextCookiesResult = {
  cookies: NetworkCookie[],
};
export type BrowserContextExposeBindingParams = {
  name: string,
  needsHandle?: boolean,
};
export type BrowserContextExposeBindingOptions = {
  needsHandle?: boolean,
};
export type BrowserContextExposeBindingResult = void;
export type BrowserContextGrantPermissionsParams = {
  permissions: string[],
  origin?: string,
};
export type BrowserContextGrantPermissionsOptions = {
  origin?: string,
};
export type BrowserContextGrantPermissionsResult = void;
export type BrowserContextNewPageParams = {};
export type BrowserContextNewPageOptions = {};
export type BrowserContextNewPageResult = {
  page: PageChannel,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyOptions = {

};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyResult = void;
export type BrowserContextSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultTimeoutNoReplyOptions = {

};
export type BrowserContextSetDefaultTimeoutNoReplyResult = void;
export type BrowserContextSetExtraHTTPHeadersParams = {
  headers: NameValue[],
};
export type BrowserContextSetExtraHTTPHeadersOptions = {

};
export type BrowserContextSetExtraHTTPHeadersResult = void;
export type BrowserContextSetGeolocationParams = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationOptions = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationResult = void;
export type BrowserContextSetHTTPCredentialsParams = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsOptions = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsResult = void;
export type BrowserContextSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type BrowserContextSetNetworkInterceptionEnabledOptions = {

};
export type BrowserContextSetNetworkInterceptionEnabledResult = void;
export type BrowserContextSetOfflineParams = {
  offline: boolean,
};
export type BrowserContextSetOfflineOptions = {

};
export type BrowserContextSetOfflineResult = void;
export type BrowserContextStorageStateParams = {};
export type BrowserContextStorageStateOptions = {};
export type BrowserContextStorageStateResult = {
  cookies: NetworkCookie[],
  origins: OriginStorage[],
};
export type BrowserContextCrNewCDPSessionParams = {
  page: PageChannel,
};
export type BrowserContextCrNewCDPSessionOptions = {

};
export type BrowserContextCrNewCDPSessionResult = {
  session: CDPSessionChannel,
};

// ----------- Page -----------
export type PageInitializer = {
  mainFrame: FrameChannel,
  viewportSize?: {
    width: number,
    height: number,
  },
  isClosed: boolean,
  videoRelativePath?: string,
};
export interface PageChannel extends Channel {
  on(event: 'bindingCall', callback: (params: PageBindingCallEvent) => void): this;
  on(event: 'close', callback: (params: PageCloseEvent) => void): this;
  on(event: 'console', callback: (params: PageConsoleEvent) => void): this;
  on(event: 'crash', callback: (params: PageCrashEvent) => void): this;
  on(event: 'dialog', callback: (params: PageDialogEvent) => void): this;
  on(event: 'download', callback: (params: PageDownloadEvent) => void): this;
  on(event: 'domcontentloaded', callback: (params: PageDomcontentloadedEvent) => void): this;
  on(event: 'fileChooser', callback: (params: PageFileChooserEvent) => void): this;
  on(event: 'frameAttached', callback: (params: PageFrameAttachedEvent) => void): this;
  on(event: 'frameDetached', callback: (params: PageFrameDetachedEvent) => void): this;
  on(event: 'load', callback: (params: PageLoadEvent) => void): this;
  on(event: 'pageError', callback: (params: PagePageErrorEvent) => void): this;
  on(event: 'popup', callback: (params: PagePopupEvent) => void): this;
  on(event: 'request', callback: (params: PageRequestEvent) => void): this;
  on(event: 'requestFailed', callback: (params: PageRequestFailedEvent) => void): this;
  on(event: 'requestFinished', callback: (params: PageRequestFinishedEvent) => void): this;
  on(event: 'response', callback: (params: PageResponseEvent) => void): this;
  on(event: 'route', callback: (params: PageRouteEvent) => void): this;
  on(event: 'video', callback: (params: PageVideoEvent) => void): this;
  on(event: 'webSocket', callback: (params: PageWebSocketEvent) => void): this;
  on(event: 'worker', callback: (params: PageWorkerEvent) => void): this;
  setDefaultNavigationTimeoutNoReply(params: PageSetDefaultNavigationTimeoutNoReplyParams, metadata?: Metadata): Promise<PageSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(params: PageSetDefaultTimeoutNoReplyParams, metadata?: Metadata): Promise<PageSetDefaultTimeoutNoReplyResult>;
  setFileChooserInterceptedNoReply(params: PageSetFileChooserInterceptedNoReplyParams, metadata?: Metadata): Promise<PageSetFileChooserInterceptedNoReplyResult>;
  addInitScript(params: PageAddInitScriptParams, metadata?: Metadata): Promise<PageAddInitScriptResult>;
  close(params: PageCloseParams, metadata?: Metadata): Promise<PageCloseResult>;
  emulateMedia(params: PageEmulateMediaParams, metadata?: Metadata): Promise<PageEmulateMediaResult>;
  exposeBinding(params: PageExposeBindingParams, metadata?: Metadata): Promise<PageExposeBindingResult>;
  goBack(params: PageGoBackParams, metadata?: Metadata): Promise<PageGoBackResult>;
  goForward(params: PageGoForwardParams, metadata?: Metadata): Promise<PageGoForwardResult>;
  opener(params?: PageOpenerParams, metadata?: Metadata): Promise<PageOpenerResult>;
  reload(params: PageReloadParams, metadata?: Metadata): Promise<PageReloadResult>;
  screenshot(params: PageScreenshotParams, metadata?: Metadata): Promise<PageScreenshotResult>;
  setExtraHTTPHeaders(params: PageSetExtraHTTPHeadersParams, metadata?: Metadata): Promise<PageSetExtraHTTPHeadersResult>;
  setNetworkInterceptionEnabled(params: PageSetNetworkInterceptionEnabledParams, metadata?: Metadata): Promise<PageSetNetworkInterceptionEnabledResult>;
  setViewportSize(params: PageSetViewportSizeParams, metadata?: Metadata): Promise<PageSetViewportSizeResult>;
  keyboardDown(params: PageKeyboardDownParams, metadata?: Metadata): Promise<PageKeyboardDownResult>;
  keyboardUp(params: PageKeyboardUpParams, metadata?: Metadata): Promise<PageKeyboardUpResult>;
  keyboardInsertText(params: PageKeyboardInsertTextParams, metadata?: Metadata): Promise<PageKeyboardInsertTextResult>;
  keyboardType(params: PageKeyboardTypeParams, metadata?: Metadata): Promise<PageKeyboardTypeResult>;
  keyboardPress(params: PageKeyboardPressParams, metadata?: Metadata): Promise<PageKeyboardPressResult>;
  mouseMove(params: PageMouseMoveParams, metadata?: Metadata): Promise<PageMouseMoveResult>;
  mouseDown(params: PageMouseDownParams, metadata?: Metadata): Promise<PageMouseDownResult>;
  mouseUp(params: PageMouseUpParams, metadata?: Metadata): Promise<PageMouseUpResult>;
  mouseClick(params: PageMouseClickParams, metadata?: Metadata): Promise<PageMouseClickResult>;
  touchscreenTap(params: PageTouchscreenTapParams, metadata?: Metadata): Promise<PageTouchscreenTapResult>;
  accessibilitySnapshot(params: PageAccessibilitySnapshotParams, metadata?: Metadata): Promise<PageAccessibilitySnapshotResult>;
  pdf(params: PagePdfParams, metadata?: Metadata): Promise<PagePdfResult>;
  crStartJSCoverage(params: PageCrStartJSCoverageParams, metadata?: Metadata): Promise<PageCrStartJSCoverageResult>;
  crStopJSCoverage(params?: PageCrStopJSCoverageParams, metadata?: Metadata): Promise<PageCrStopJSCoverageResult>;
  crStartCSSCoverage(params: PageCrStartCSSCoverageParams, metadata?: Metadata): Promise<PageCrStartCSSCoverageResult>;
  crStopCSSCoverage(params?: PageCrStopCSSCoverageParams, metadata?: Metadata): Promise<PageCrStopCSSCoverageResult>;
  bringToFront(params?: PageBringToFrontParams, metadata?: Metadata): Promise<PageBringToFrontResult>;
}
export type PageBindingCallEvent = {
  binding: BindingCallChannel,
};
export type PageCloseEvent = {};
export type PageConsoleEvent = {
  message: ConsoleMessageChannel,
};
export type PageCrashEvent = {};
export type PageDialogEvent = {
  dialog: DialogChannel,
};
export type PageDownloadEvent = {
  download: DownloadChannel,
};
export type PageDomcontentloadedEvent = {};
export type PageFileChooserEvent = {
  element: ElementHandleChannel,
  isMultiple: boolean,
};
export type PageFrameAttachedEvent = {
  frame: FrameChannel,
};
export type PageFrameDetachedEvent = {
  frame: FrameChannel,
};
export type PageLoadEvent = {};
export type PagePageErrorEvent = {
  error: SerializedError,
};
export type PagePopupEvent = {
  page: PageChannel,
};
export type PageRequestEvent = {
  request: RequestChannel,
};
export type PageRequestFailedEvent = {
  request: RequestChannel,
  failureText?: string,
  responseEndTiming: number,
};
export type PageRequestFinishedEvent = {
  request: RequestChannel,
  responseEndTiming: number,
};
export type PageResponseEvent = {
  response: ResponseChannel,
};
export type PageRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type PageVideoEvent = {
  relativePath: string,
};
export type PageWebSocketEvent = {
  webSocket: WebSocketChannel,
};
export type PageWorkerEvent = {
  worker: WorkerChannel,
};
export type PageSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultNavigationTimeoutNoReplyOptions = {

};
export type PageSetDefaultNavigationTimeoutNoReplyResult = void;
export type PageSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultTimeoutNoReplyOptions = {

};
export type PageSetDefaultTimeoutNoReplyResult = void;
export type PageSetFileChooserInterceptedNoReplyParams = {
  intercepted: boolean,
};
export type PageSetFileChooserInterceptedNoReplyOptions = {

};
export type PageSetFileChooserInterceptedNoReplyResult = void;
export type PageAddInitScriptParams = {
  source: string,
};
export type PageAddInitScriptOptions = {

};
export type PageAddInitScriptResult = void;
export type PageCloseParams = {
  runBeforeUnload?: boolean,
};
export type PageCloseOptions = {
  runBeforeUnload?: boolean,
};
export type PageCloseResult = void;
export type PageEmulateMediaParams = {
  media?: 'screen' | 'print' | 'null',
  colorScheme?: 'dark' | 'light' | 'no-preference' | 'null',
};
export type PageEmulateMediaOptions = {
  media?: 'screen' | 'print' | 'null',
  colorScheme?: 'dark' | 'light' | 'no-preference' | 'null',
};
export type PageEmulateMediaResult = void;
export type PageExposeBindingParams = {
  name: string,
  needsHandle?: boolean,
};
export type PageExposeBindingOptions = {
  needsHandle?: boolean,
};
export type PageExposeBindingResult = void;
export type PageGoBackParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackResult = {
  response?: ResponseChannel,
};
export type PageGoForwardParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardResult = {
  response?: ResponseChannel,
};
export type PageOpenerParams = {};
export type PageOpenerOptions = {};
export type PageOpenerResult = {
  page?: PageChannel,
};
export type PageReloadParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadResult = {
  response?: ResponseChannel,
};
export type PageScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: Rect,
};
export type PageScreenshotOptions = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: Rect,
};
export type PageScreenshotResult = {
  binary: Binary,
};
export type PageSetExtraHTTPHeadersParams = {
  headers: NameValue[],
};
export type PageSetExtraHTTPHeadersOptions = {

};
export type PageSetExtraHTTPHeadersResult = void;
export type PageSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type PageSetNetworkInterceptionEnabledOptions = {

};
export type PageSetNetworkInterceptionEnabledResult = void;
export type PageSetViewportSizeParams = {
  viewportSize: {
    width: number,
    height: number,
  },
};
export type PageSetViewportSizeOptions = {

};
export type PageSetViewportSizeResult = void;
export type PageKeyboardDownParams = {
  key: string,
};
export type PageKeyboardDownOptions = {

};
export type PageKeyboardDownResult = void;
export type PageKeyboardUpParams = {
  key: string,
};
export type PageKeyboardUpOptions = {

};
export type PageKeyboardUpResult = void;
export type PageKeyboardInsertTextParams = {
  text: string,
};
export type PageKeyboardInsertTextOptions = {

};
export type PageKeyboardInsertTextResult = void;
export type PageKeyboardTypeParams = {
  text: string,
  delay?: number,
};
export type PageKeyboardTypeOptions = {
  delay?: number,
};
export type PageKeyboardTypeResult = void;
export type PageKeyboardPressParams = {
  key: string,
  delay?: number,
};
export type PageKeyboardPressOptions = {
  delay?: number,
};
export type PageKeyboardPressResult = void;
export type PageMouseMoveParams = {
  x: number,
  y: number,
  steps?: number,
};
export type PageMouseMoveOptions = {
  steps?: number,
};
export type PageMouseMoveResult = void;
export type PageMouseDownParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownOptions = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownResult = void;
export type PageMouseUpParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpOptions = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpResult = void;
export type PageMouseClickParams = {
  x: number,
  y: number,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickOptions = {
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickResult = void;
export type PageTouchscreenTapParams = {
  x: number,
  y: number,
};
export type PageTouchscreenTapOptions = {

};
export type PageTouchscreenTapResult = void;
export type PageAccessibilitySnapshotParams = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotOptions = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotResult = {
  rootAXNode?: AXNode,
};
export type PagePdfParams = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfOptions = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfResult = {
  pdf: Binary,
};
export type PageCrStartJSCoverageParams = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageOptions = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageResult = void;
export type PageCrStopJSCoverageParams = {};
export type PageCrStopJSCoverageOptions = {};
export type PageCrStopJSCoverageResult = {
  entries: {
    url: string,
    scriptId: string,
    source?: string,
    functions: {
      functionName: string,
      isBlockCoverage: boolean,
      ranges: {
        startOffset: number,
        endOffset: number,
        count: number,
      }[],
    }[],
  }[],
};
export type PageCrStartCSSCoverageParams = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageOptions = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageResult = void;
export type PageCrStopCSSCoverageParams = {};
export type PageCrStopCSSCoverageOptions = {};
export type PageCrStopCSSCoverageResult = {
  entries: {
    url: string,
    text?: string,
    ranges: {
      start: number,
      end: number,
    }[],
  }[],
};
export type PageBringToFrontParams = {};
export type PageBringToFrontOptions = {};
export type PageBringToFrontResult = void;

// ----------- Frame -----------
export type FrameInitializer = {
  url: string,
  name: string,
  parentFrame?: FrameChannel,
  loadStates: ('load' | 'domcontentloaded' | 'networkidle')[],
};
export interface FrameChannel extends Channel {
  on(event: 'loadstate', callback: (params: FrameLoadstateEvent) => void): this;
  on(event: 'navigated', callback: (params: FrameNavigatedEvent) => void): this;
  evalOnSelector(params: FrameEvalOnSelectorParams, metadata?: Metadata): Promise<FrameEvalOnSelectorResult>;
  evalOnSelectorAll(params: FrameEvalOnSelectorAllParams, metadata?: Metadata): Promise<FrameEvalOnSelectorAllResult>;
  addScriptTag(params: FrameAddScriptTagParams, metadata?: Metadata): Promise<FrameAddScriptTagResult>;
  addStyleTag(params: FrameAddStyleTagParams, metadata?: Metadata): Promise<FrameAddStyleTagResult>;
  check(params: FrameCheckParams, metadata?: Metadata): Promise<FrameCheckResult>;
  click(params: FrameClickParams, metadata?: Metadata): Promise<FrameClickResult>;
  content(params?: FrameContentParams, metadata?: Metadata): Promise<FrameContentResult>;
  dblclick(params: FrameDblclickParams, metadata?: Metadata): Promise<FrameDblclickResult>;
  dispatchEvent(params: FrameDispatchEventParams, metadata?: Metadata): Promise<FrameDispatchEventResult>;
  evaluateExpression(params: FrameEvaluateExpressionParams, metadata?: Metadata): Promise<FrameEvaluateExpressionResult>;
  evaluateExpressionHandle(params: FrameEvaluateExpressionHandleParams, metadata?: Metadata): Promise<FrameEvaluateExpressionHandleResult>;
  fill(params: FrameFillParams, metadata?: Metadata): Promise<FrameFillResult>;
  focus(params: FrameFocusParams, metadata?: Metadata): Promise<FrameFocusResult>;
  frameElement(params?: FrameFrameElementParams, metadata?: Metadata): Promise<FrameFrameElementResult>;
  getAttribute(params: FrameGetAttributeParams, metadata?: Metadata): Promise<FrameGetAttributeResult>;
  goto(params: FrameGotoParams, metadata?: Metadata): Promise<FrameGotoResult>;
  hover(params: FrameHoverParams, metadata?: Metadata): Promise<FrameHoverResult>;
  innerHTML(params: FrameInnerHTMLParams, metadata?: Metadata): Promise<FrameInnerHTMLResult>;
  innerText(params: FrameInnerTextParams, metadata?: Metadata): Promise<FrameInnerTextResult>;
  press(params: FramePressParams, metadata?: Metadata): Promise<FramePressResult>;
  querySelector(params: FrameQuerySelectorParams, metadata?: Metadata): Promise<FrameQuerySelectorResult>;
  querySelectorAll(params: FrameQuerySelectorAllParams, metadata?: Metadata): Promise<FrameQuerySelectorAllResult>;
  selectOption(params: FrameSelectOptionParams, metadata?: Metadata): Promise<FrameSelectOptionResult>;
  setContent(params: FrameSetContentParams, metadata?: Metadata): Promise<FrameSetContentResult>;
  setInputFiles(params: FrameSetInputFilesParams, metadata?: Metadata): Promise<FrameSetInputFilesResult>;
  tap(params: FrameTapParams, metadata?: Metadata): Promise<FrameTapResult>;
  textContent(params: FrameTextContentParams, metadata?: Metadata): Promise<FrameTextContentResult>;
  title(params?: FrameTitleParams, metadata?: Metadata): Promise<FrameTitleResult>;
  type(params: FrameTypeParams, metadata?: Metadata): Promise<FrameTypeResult>;
  uncheck(params: FrameUncheckParams, metadata?: Metadata): Promise<FrameUncheckResult>;
  waitForFunction(params: FrameWaitForFunctionParams, metadata?: Metadata): Promise<FrameWaitForFunctionResult>;
  waitForSelector(params: FrameWaitForSelectorParams, metadata?: Metadata): Promise<FrameWaitForSelectorResult>;
  extendInjectedScript(params: FrameExtendInjectedScriptParams, metadata?: Metadata): Promise<FrameExtendInjectedScriptResult>;
}
export type FrameLoadstateEvent = {
  add?: 'load' | 'domcontentloaded' | 'networkidle',
  remove?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameNavigatedEvent = {
  url: string,
  name: string,
  newDocument?: {
    request?: RequestChannel,
  },
  error?: string,
};
export type FrameEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type FrameEvalOnSelectorOptions = {

};
export type FrameEvalOnSelectorResult = {
  value: SerializedValue,
};
export type FrameEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type FrameEvalOnSelectorAllOptions = {

};
export type FrameEvalOnSelectorAllResult = {
  value: SerializedValue,
};
export type FrameAddScriptTagParams = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagOptions = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagResult = {
  element: ElementHandleChannel,
};
export type FrameAddStyleTagParams = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagOptions = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagResult = {
  element: ElementHandleChannel,
};
export type FrameCheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckResult = void;
export type FrameClickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickResult = void;
export type FrameContentParams = {};
export type FrameContentOptions = {};
export type FrameContentResult = {
  value: string,
};
export type FrameDblclickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickResult = void;
export type FrameDispatchEventParams = {
  selector: string,
  type: string,
  eventInit: SerializedArgument,
  timeout?: number,
};
export type FrameDispatchEventOptions = {
  timeout?: number,
};
export type FrameDispatchEventResult = void;
export type FrameEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionOptions = {
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionResult = {
  value: SerializedValue,
};
export type FrameEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionHandleOptions = {
  world?: 'main' | 'utility',
};
export type FrameEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type FrameFillParams = {
  selector: string,
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillResult = void;
export type FrameFocusParams = {
  selector: string,
  timeout?: number,
};
export type FrameFocusOptions = {
  timeout?: number,
};
export type FrameFocusResult = void;
export type FrameFrameElementParams = {};
export type FrameFrameElementOptions = {};
export type FrameFrameElementResult = {
  element: ElementHandleChannel,
};
export type FrameGetAttributeParams = {
  selector: string,
  name: string,
  timeout?: number,
};
export type FrameGetAttributeOptions = {
  timeout?: number,
};
export type FrameGetAttributeResult = {
  value?: string,
};
export type FrameGotoParams = {
  url: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoResult = {
  response?: ResponseChannel,
};
export type FrameHoverParams = {
  selector: string,
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type FrameHoverOptions = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type FrameHoverResult = void;
export type FrameInnerHTMLParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerHTMLOptions = {
  timeout?: number,
};
export type FrameInnerHTMLResult = {
  value: string,
};
export type FrameInnerTextParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerTextOptions = {
  timeout?: number,
};
export type FrameInnerTextResult = {
  value: string,
};
export type FramePressParams = {
  selector: string,
  key: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressResult = void;
export type FrameQuerySelectorParams = {
  selector: string,
};
export type FrameQuerySelectorOptions = {

};
export type FrameQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type FrameQuerySelectorAllParams = {
  selector: string,
};
export type FrameQuerySelectorAllOptions = {

};
export type FrameQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type FrameSelectOptionParams = {
  selector: string,
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionOptions = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionResult = {
  values: string[],
};
export type FrameSetContentParams = {
  html: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentOptions = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentResult = void;
export type FrameSetInputFilesParams = {
  selector: string,
  files: {
    name: string,
    mimeType: string,
    buffer: Binary,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesResult = void;
export type FrameTapParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type FrameTapOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type FrameTapResult = void;
export type FrameTextContentParams = {
  selector: string,
  timeout?: number,
};
export type FrameTextContentOptions = {
  timeout?: number,
};
export type FrameTextContentResult = {
  value?: string,
};
export type FrameTitleParams = {};
export type FrameTitleOptions = {};
export type FrameTitleResult = {
  value: string,
};
export type FrameTypeParams = {
  selector: string,
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeResult = void;
export type FrameUncheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckResult = void;
export type FrameWaitForFunctionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionOptions = {
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionResult = {
  handle: JSHandleChannel,
};
export type FrameWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorOptions = {
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorResult = {
  element?: ElementHandleChannel,
};
export type FrameExtendInjectedScriptParams = {
  source: string,
  arg: SerializedArgument,
};
export type FrameExtendInjectedScriptOptions = {

};
export type FrameExtendInjectedScriptResult = {
  handle: JSHandleChannel,
};

// ----------- Worker -----------
export type WorkerInitializer = {
  url: string,
};
export interface WorkerChannel extends Channel {
  on(event: 'close', callback: (params: WorkerCloseEvent) => void): this;
  evaluateExpression(params: WorkerEvaluateExpressionParams, metadata?: Metadata): Promise<WorkerEvaluateExpressionResult>;
  evaluateExpressionHandle(params: WorkerEvaluateExpressionHandleParams, metadata?: Metadata): Promise<WorkerEvaluateExpressionHandleResult>;
}
export type WorkerCloseEvent = {};
export type WorkerEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type WorkerEvaluateExpressionOptions = {

};
export type WorkerEvaluateExpressionResult = {
  value: SerializedValue,
};
export type WorkerEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type WorkerEvaluateExpressionHandleOptions = {

};
export type WorkerEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};

// ----------- JSHandle -----------
export type JSHandleInitializer = {
  preview: string,
};
export interface JSHandleChannel extends Channel {
  on(event: 'previewUpdated', callback: (params: JSHandlePreviewUpdatedEvent) => void): this;
  dispose(params?: JSHandleDisposeParams, metadata?: Metadata): Promise<JSHandleDisposeResult>;
  evaluateExpression(params: JSHandleEvaluateExpressionParams, metadata?: Metadata): Promise<JSHandleEvaluateExpressionResult>;
  evaluateExpressionHandle(params: JSHandleEvaluateExpressionHandleParams, metadata?: Metadata): Promise<JSHandleEvaluateExpressionHandleResult>;
  getPropertyList(params?: JSHandleGetPropertyListParams, metadata?: Metadata): Promise<JSHandleGetPropertyListResult>;
  getProperty(params: JSHandleGetPropertyParams, metadata?: Metadata): Promise<JSHandleGetPropertyResult>;
  jsonValue(params?: JSHandleJsonValueParams, metadata?: Metadata): Promise<JSHandleJsonValueResult>;
}
export type JSHandlePreviewUpdatedEvent = {
  preview: string,
};
export type JSHandleDisposeParams = {};
export type JSHandleDisposeOptions = {};
export type JSHandleDisposeResult = void;
export type JSHandleEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type JSHandleEvaluateExpressionOptions = {

};
export type JSHandleEvaluateExpressionResult = {
  value: SerializedValue,
};
export type JSHandleEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type JSHandleEvaluateExpressionHandleOptions = {

};
export type JSHandleEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type JSHandleGetPropertyListParams = {};
export type JSHandleGetPropertyListOptions = {};
export type JSHandleGetPropertyListResult = {
  properties: {
    name: string,
    value: JSHandleChannel,
  }[],
};
export type JSHandleGetPropertyParams = {
  name: string,
};
export type JSHandleGetPropertyOptions = {

};
export type JSHandleGetPropertyResult = {
  handle: JSHandleChannel,
};
export type JSHandleJsonValueParams = {};
export type JSHandleJsonValueOptions = {};
export type JSHandleJsonValueResult = {
  value: SerializedValue,
};

// ----------- ElementHandle -----------
export type ElementHandleInitializer = {};
export interface ElementHandleChannel extends JSHandleChannel {
  evalOnSelector(params: ElementHandleEvalOnSelectorParams, metadata?: Metadata): Promise<ElementHandleEvalOnSelectorResult>;
  evalOnSelectorAll(params: ElementHandleEvalOnSelectorAllParams, metadata?: Metadata): Promise<ElementHandleEvalOnSelectorAllResult>;
  boundingBox(params?: ElementHandleBoundingBoxParams, metadata?: Metadata): Promise<ElementHandleBoundingBoxResult>;
  check(params: ElementHandleCheckParams, metadata?: Metadata): Promise<ElementHandleCheckResult>;
  click(params: ElementHandleClickParams, metadata?: Metadata): Promise<ElementHandleClickResult>;
  contentFrame(params?: ElementHandleContentFrameParams, metadata?: Metadata): Promise<ElementHandleContentFrameResult>;
  dblclick(params: ElementHandleDblclickParams, metadata?: Metadata): Promise<ElementHandleDblclickResult>;
  dispatchEvent(params: ElementHandleDispatchEventParams, metadata?: Metadata): Promise<ElementHandleDispatchEventResult>;
  fill(params: ElementHandleFillParams, metadata?: Metadata): Promise<ElementHandleFillResult>;
  focus(params?: ElementHandleFocusParams, metadata?: Metadata): Promise<ElementHandleFocusResult>;
  getAttribute(params: ElementHandleGetAttributeParams, metadata?: Metadata): Promise<ElementHandleGetAttributeResult>;
  hover(params: ElementHandleHoverParams, metadata?: Metadata): Promise<ElementHandleHoverResult>;
  innerHTML(params?: ElementHandleInnerHTMLParams, metadata?: Metadata): Promise<ElementHandleInnerHTMLResult>;
  innerText(params?: ElementHandleInnerTextParams, metadata?: Metadata): Promise<ElementHandleInnerTextResult>;
  ownerFrame(params?: ElementHandleOwnerFrameParams, metadata?: Metadata): Promise<ElementHandleOwnerFrameResult>;
  press(params: ElementHandlePressParams, metadata?: Metadata): Promise<ElementHandlePressResult>;
  querySelector(params: ElementHandleQuerySelectorParams, metadata?: Metadata): Promise<ElementHandleQuerySelectorResult>;
  querySelectorAll(params: ElementHandleQuerySelectorAllParams, metadata?: Metadata): Promise<ElementHandleQuerySelectorAllResult>;
  screenshot(params: ElementHandleScreenshotParams, metadata?: Metadata): Promise<ElementHandleScreenshotResult>;
  scrollIntoViewIfNeeded(params: ElementHandleScrollIntoViewIfNeededParams, metadata?: Metadata): Promise<ElementHandleScrollIntoViewIfNeededResult>;
  selectOption(params: ElementHandleSelectOptionParams, metadata?: Metadata): Promise<ElementHandleSelectOptionResult>;
  selectText(params: ElementHandleSelectTextParams, metadata?: Metadata): Promise<ElementHandleSelectTextResult>;
  setInputFiles(params: ElementHandleSetInputFilesParams, metadata?: Metadata): Promise<ElementHandleSetInputFilesResult>;
  tap(params: ElementHandleTapParams, metadata?: Metadata): Promise<ElementHandleTapResult>;
  textContent(params?: ElementHandleTextContentParams, metadata?: Metadata): Promise<ElementHandleTextContentResult>;
  type(params: ElementHandleTypeParams, metadata?: Metadata): Promise<ElementHandleTypeResult>;
  uncheck(params: ElementHandleUncheckParams, metadata?: Metadata): Promise<ElementHandleUncheckResult>;
  waitForElementState(params: ElementHandleWaitForElementStateParams, metadata?: Metadata): Promise<ElementHandleWaitForElementStateResult>;
  waitForSelector(params: ElementHandleWaitForSelectorParams, metadata?: Metadata): Promise<ElementHandleWaitForSelectorResult>;
}
export type ElementHandleEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElementHandleEvalOnSelectorOptions = {

};
export type ElementHandleEvalOnSelectorResult = {
  value: SerializedValue,
};
export type ElementHandleEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElementHandleEvalOnSelectorAllOptions = {

};
export type ElementHandleEvalOnSelectorAllResult = {
  value: SerializedValue,
};
export type ElementHandleBoundingBoxParams = {};
export type ElementHandleBoundingBoxOptions = {};
export type ElementHandleBoundingBoxResult = {
  value?: Rect,
};
export type ElementHandleCheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckResult = void;
export type ElementHandleClickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickResult = void;
export type ElementHandleContentFrameParams = {};
export type ElementHandleContentFrameOptions = {};
export type ElementHandleContentFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandleDblclickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickResult = void;
export type ElementHandleDispatchEventParams = {
  type: string,
  eventInit: SerializedArgument,
};
export type ElementHandleDispatchEventOptions = {

};
export type ElementHandleDispatchEventResult = void;
export type ElementHandleFillParams = {
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillResult = void;
export type ElementHandleFocusParams = {};
export type ElementHandleFocusOptions = {};
export type ElementHandleFocusResult = void;
export type ElementHandleGetAttributeParams = {
  name: string,
};
export type ElementHandleGetAttributeOptions = {

};
export type ElementHandleGetAttributeResult = {
  value?: string,
};
export type ElementHandleHoverParams = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type ElementHandleHoverOptions = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type ElementHandleHoverResult = void;
export type ElementHandleInnerHTMLParams = {};
export type ElementHandleInnerHTMLOptions = {};
export type ElementHandleInnerHTMLResult = {
  value: string,
};
export type ElementHandleInnerTextParams = {};
export type ElementHandleInnerTextOptions = {};
export type ElementHandleInnerTextResult = {
  value: string,
};
export type ElementHandleOwnerFrameParams = {};
export type ElementHandleOwnerFrameOptions = {};
export type ElementHandleOwnerFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandlePressParams = {
  key: string,
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressOptions = {
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressResult = void;
export type ElementHandleQuerySelectorParams = {
  selector: string,
};
export type ElementHandleQuerySelectorOptions = {

};
export type ElementHandleQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type ElementHandleQuerySelectorAllParams = {
  selector: string,
};
export type ElementHandleQuerySelectorAllOptions = {

};
export type ElementHandleQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type ElementHandleScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotOptions = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotResult = {
  binary: Binary,
};
export type ElementHandleScrollIntoViewIfNeededParams = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededOptions = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededResult = void;
export type ElementHandleSelectOptionParams = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionOptions = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionResult = {
  values: string[],
};
export type ElementHandleSelectTextParams = {
  timeout?: number,
};
export type ElementHandleSelectTextOptions = {
  timeout?: number,
};
export type ElementHandleSelectTextResult = void;
export type ElementHandleSetInputFilesParams = {
  files: {
    name: string,
    mimeType: string,
    buffer: Binary,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesOptions = {
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesResult = void;
export type ElementHandleTapParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type ElementHandleTapOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: Point,
  timeout?: number,
};
export type ElementHandleTapResult = void;
export type ElementHandleTextContentParams = {};
export type ElementHandleTextContentOptions = {};
export type ElementHandleTextContentResult = {
  value?: string,
};
export type ElementHandleTypeParams = {
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeOptions = {
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeResult = void;
export type ElementHandleUncheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckOptions = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckResult = void;
export type ElementHandleWaitForElementStateParams = {
  state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled',
  timeout?: number,
};
export type ElementHandleWaitForElementStateOptions = {
  timeout?: number,
};
export type ElementHandleWaitForElementStateResult = void;
export type ElementHandleWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type ElementHandleWaitForSelectorOptions = {
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type ElementHandleWaitForSelectorResult = {
  element?: ElementHandleChannel,
};

// ----------- Request -----------
export type RequestInitializer = {
  frame: FrameChannel,
  url: string,
  resourceType: string,
  method: string,
  postData?: Binary,
  headers: {
    name: string,
    value: string,
  }[],
  isNavigationRequest: boolean,
  redirectedFrom?: RequestChannel,
};
export interface RequestChannel extends Channel {
  response(params?: RequestResponseParams, metadata?: Metadata): Promise<RequestResponseResult>;
}
export type RequestResponseParams = {};
export type RequestResponseOptions = {};
export type RequestResponseResult = {
  response?: ResponseChannel,
};

// ----------- Route -----------
export type RouteInitializer = {
  request: RequestChannel,
};
export interface RouteChannel extends Channel {
  abort(params: RouteAbortParams, metadata?: Metadata): Promise<RouteAbortResult>;
  continue(params: RouteContinueParams, metadata?: Metadata): Promise<RouteContinueResult>;
  fulfill(params: RouteFulfillParams, metadata?: Metadata): Promise<RouteFulfillResult>;
}
export type RouteAbortParams = {
  errorCode?: string,
};
export type RouteAbortOptions = {
  errorCode?: string,
};
export type RouteAbortResult = void;
export type RouteContinueParams = {
  url?: string,
  method?: string,
  headers?: NameValue[],
  postData?: Binary,
};
export type RouteContinueOptions = {
  url?: string,
  method?: string,
  headers?: NameValue[],
  postData?: Binary,
};
export type RouteContinueResult = void;
export type RouteFulfillParams = {
  status?: number,
  headers?: NameValue[],
  body?: string,
  isBase64?: boolean,
};
export type RouteFulfillOptions = {
  status?: number,
  headers?: NameValue[],
  body?: string,
  isBase64?: boolean,
};
export type RouteFulfillResult = void;

export type ResourceTiming = {
  startTime: number,
  domainLookupStart: number,
  domainLookupEnd: number,
  connectStart: number,
  secureConnectionStart: number,
  connectEnd: number,
  requestStart: number,
  responseStart: number,
};

// ----------- Response -----------
export type ResponseInitializer = {
  request: RequestChannel,
  url: string,
  status: number,
  statusText: string,
  requestHeaders: {
    name: string,
    value: string,
  }[],
  headers: {
    name: string,
    value: string,
  }[],
  timing: ResourceTiming,
};
export interface ResponseChannel extends Channel {
  body(params?: ResponseBodyParams, metadata?: Metadata): Promise<ResponseBodyResult>;
  finished(params?: ResponseFinishedParams, metadata?: Metadata): Promise<ResponseFinishedResult>;
}
export type ResponseBodyParams = {};
export type ResponseBodyOptions = {};
export type ResponseBodyResult = {
  binary: Binary,
};
export type ResponseFinishedParams = {};
export type ResponseFinishedOptions = {};
export type ResponseFinishedResult = {
  error?: string,
};

// ----------- WebSocket -----------
export type WebSocketInitializer = {
  url: string,
};
export interface WebSocketChannel extends Channel {
  on(event: 'open', callback: (params: WebSocketOpenEvent) => void): this;
  on(event: 'frameSent', callback: (params: WebSocketFrameSentEvent) => void): this;
  on(event: 'frameReceived', callback: (params: WebSocketFrameReceivedEvent) => void): this;
  on(event: 'socketError', callback: (params: WebSocketSocketErrorEvent) => void): this;
  on(event: 'close', callback: (params: WebSocketCloseEvent) => void): this;
}
export type WebSocketOpenEvent = {};
export type WebSocketFrameSentEvent = {
  opcode: number,
  data: string,
};
export type WebSocketFrameReceivedEvent = {
  opcode: number,
  data: string,
};
export type WebSocketSocketErrorEvent = {
  error: string,
};
export type WebSocketCloseEvent = {};

// ----------- ConsoleMessage -----------
export type ConsoleMessageInitializer = {
  type: string,
  text: string,
  args: JSHandleChannel[],
  location: {
    url: string,
    lineNumber: number,
    columnNumber: number,
  },
};
export interface ConsoleMessageChannel extends Channel {
}

// ----------- BindingCall -----------
export type BindingCallInitializer = {
  frame: FrameChannel,
  name: string,
  args?: SerializedValue[],
  handle?: JSHandleChannel,
};
export interface BindingCallChannel extends Channel {
  reject(params: BindingCallRejectParams, metadata?: Metadata): Promise<BindingCallRejectResult>;
  resolve(params: BindingCallResolveParams, metadata?: Metadata): Promise<BindingCallResolveResult>;
}
export type BindingCallRejectParams = {
  error: SerializedError,
};
export type BindingCallRejectOptions = {

};
export type BindingCallRejectResult = void;
export type BindingCallResolveParams = {
  result: SerializedArgument,
};
export type BindingCallResolveOptions = {

};
export type BindingCallResolveResult = void;

// ----------- Dialog -----------
export type DialogInitializer = {
  type: string,
  message: string,
  defaultValue: string,
};
export interface DialogChannel extends Channel {
  accept(params: DialogAcceptParams, metadata?: Metadata): Promise<DialogAcceptResult>;
  dismiss(params?: DialogDismissParams, metadata?: Metadata): Promise<DialogDismissResult>;
}
export type DialogAcceptParams = {
  promptText?: string,
};
export type DialogAcceptOptions = {
  promptText?: string,
};
export type DialogAcceptResult = void;
export type DialogDismissParams = {};
export type DialogDismissOptions = {};
export type DialogDismissResult = void;

// ----------- Download -----------
export type DownloadInitializer = {
  url: string,
  suggestedFilename: string,
};
export interface DownloadChannel extends Channel {
  path(params?: DownloadPathParams, metadata?: Metadata): Promise<DownloadPathResult>;
  saveAs(params: DownloadSaveAsParams, metadata?: Metadata): Promise<DownloadSaveAsResult>;
  saveAsStream(params?: DownloadSaveAsStreamParams, metadata?: Metadata): Promise<DownloadSaveAsStreamResult>;
  failure(params?: DownloadFailureParams, metadata?: Metadata): Promise<DownloadFailureResult>;
  stream(params?: DownloadStreamParams, metadata?: Metadata): Promise<DownloadStreamResult>;
  delete(params?: DownloadDeleteParams, metadata?: Metadata): Promise<DownloadDeleteResult>;
}
export type DownloadPathParams = {};
export type DownloadPathOptions = {};
export type DownloadPathResult = {
  value?: string,
};
export type DownloadSaveAsParams = {
  path: string,
};
export type DownloadSaveAsOptions = {

};
export type DownloadSaveAsResult = void;
export type DownloadSaveAsStreamParams = {};
export type DownloadSaveAsStreamOptions = {};
export type DownloadSaveAsStreamResult = {
  stream: StreamChannel,
};
export type DownloadFailureParams = {};
export type DownloadFailureOptions = {};
export type DownloadFailureResult = {
  error?: string,
};
export type DownloadStreamParams = {};
export type DownloadStreamOptions = {};
export type DownloadStreamResult = {
  stream?: StreamChannel,
};
export type DownloadDeleteParams = {};
export type DownloadDeleteOptions = {};
export type DownloadDeleteResult = void;

// ----------- Stream -----------
export type StreamInitializer = {};
export interface StreamChannel extends Channel {
  read(params: StreamReadParams, metadata?: Metadata): Promise<StreamReadResult>;
  close(params?: StreamCloseParams, metadata?: Metadata): Promise<StreamCloseResult>;
}
export type StreamReadParams = {
  size?: number,
};
export type StreamReadOptions = {
  size?: number,
};
export type StreamReadResult = {
  binary: Binary,
};
export type StreamCloseParams = {};
export type StreamCloseOptions = {};
export type StreamCloseResult = void;

// ----------- CDPSession -----------
export type CDPSessionInitializer = {};
export interface CDPSessionChannel extends Channel {
  on(event: 'event', callback: (params: CDPSessionEventEvent) => void): this;
  send(params: CDPSessionSendParams, metadata?: Metadata): Promise<CDPSessionSendResult>;
  detach(params?: CDPSessionDetachParams, metadata?: Metadata): Promise<CDPSessionDetachResult>;
}
export type CDPSessionEventEvent = {
  method: string,
  params?: any,
};
export type CDPSessionSendParams = {
  method: string,
  params?: any,
};
export type CDPSessionSendOptions = {
  params?: any,
};
export type CDPSessionSendResult = {
  result: any,
};
export type CDPSessionDetachParams = {};
export type CDPSessionDetachOptions = {};
export type CDPSessionDetachResult = void;

// ----------- Electron -----------
export type ElectronInitializer = {};
export interface ElectronChannel extends Channel {
  launch(params: ElectronLaunchParams, metadata?: Metadata): Promise<ElectronLaunchResult>;
}
export type ElectronLaunchParams = {
  executablePath: string,
  args?: string[],
  cwd?: string,
  env?: NameValue[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
};
export type ElectronLaunchOptions = {
  args?: string[],
  cwd?: string,
  env?: NameValue[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
};
export type ElectronLaunchResult = {
  electronApplication: ElectronApplicationChannel,
};

// ----------- ElectronApplication -----------
export type ElectronApplicationInitializer = {};
export interface ElectronApplicationChannel extends Channel {
  on(event: 'context', callback: (params: ElectronApplicationContextEvent) => void): this;
  on(event: 'close', callback: (params: ElectronApplicationCloseEvent) => void): this;
  on(event: 'window', callback: (params: ElectronApplicationWindowEvent) => void): this;
  newBrowserWindow(params: ElectronApplicationNewBrowserWindowParams, metadata?: Metadata): Promise<ElectronApplicationNewBrowserWindowResult>;
  evaluateExpression(params: ElectronApplicationEvaluateExpressionParams, metadata?: Metadata): Promise<ElectronApplicationEvaluateExpressionResult>;
  evaluateExpressionHandle(params: ElectronApplicationEvaluateExpressionHandleParams, metadata?: Metadata): Promise<ElectronApplicationEvaluateExpressionHandleResult>;
  close(params?: ElectronApplicationCloseParams, metadata?: Metadata): Promise<ElectronApplicationCloseResult>;
}
export type ElectronApplicationContextEvent = {
  context: BrowserContextChannel,
};
export type ElectronApplicationCloseEvent = {};
export type ElectronApplicationWindowEvent = {
  page: PageChannel,
  browserWindow: JSHandleChannel,
};
export type ElectronApplicationNewBrowserWindowParams = {
  arg: SerializedArgument,
};
export type ElectronApplicationNewBrowserWindowOptions = {

};
export type ElectronApplicationNewBrowserWindowResult = {
  page: PageChannel,
};
export type ElectronApplicationEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionOptions = {

};
export type ElectronApplicationEvaluateExpressionResult = {
  value: SerializedValue,
};
export type ElectronApplicationEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionHandleOptions = {

};
export type ElectronApplicationEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type ElectronApplicationCloseParams = {};
export type ElectronApplicationCloseOptions = {};
export type ElectronApplicationCloseResult = void;

// ----------- Android -----------
export type AndroidInitializer = {};
export interface AndroidChannel extends Channel {
  devices(params?: AndroidDevicesParams, metadata?: Metadata): Promise<AndroidDevicesResult>;
  setDefaultTimeoutNoReply(params: AndroidSetDefaultTimeoutNoReplyParams, metadata?: Metadata): Promise<AndroidSetDefaultTimeoutNoReplyResult>;
}
export type AndroidDevicesParams = {};
export type AndroidDevicesOptions = {};
export type AndroidDevicesResult = {
  devices: AndroidDeviceChannel[],
};
export type AndroidSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type AndroidSetDefaultTimeoutNoReplyOptions = {

};
export type AndroidSetDefaultTimeoutNoReplyResult = void;

// ----------- AndroidSocket -----------
export type AndroidSocketInitializer = {};
export interface AndroidSocketChannel extends Channel {
  on(event: 'data', callback: (params: AndroidSocketDataEvent) => void): this;
  write(params: AndroidSocketWriteParams, metadata?: Metadata): Promise<AndroidSocketWriteResult>;
  close(params?: AndroidSocketCloseParams, metadata?: Metadata): Promise<AndroidSocketCloseResult>;
}
export type AndroidSocketDataEvent = {
  data: Binary,
};
export type AndroidSocketWriteParams = {
  data: Binary,
};
export type AndroidSocketWriteOptions = {

};
export type AndroidSocketWriteResult = void;
export type AndroidSocketCloseParams = {};
export type AndroidSocketCloseOptions = {};
export type AndroidSocketCloseResult = void;

// ----------- AndroidDevice -----------
export type AndroidDeviceInitializer = {
  model: string,
  serial: string,
};
export interface AndroidDeviceChannel extends Channel {
  on(event: 'webViewAdded', callback: (params: AndroidDeviceWebViewAddedEvent) => void): this;
  on(event: 'webViewRemoved', callback: (params: AndroidDeviceWebViewRemovedEvent) => void): this;
  wait(params: AndroidDeviceWaitParams, metadata?: Metadata): Promise<AndroidDeviceWaitResult>;
  fill(params: AndroidDeviceFillParams, metadata?: Metadata): Promise<AndroidDeviceFillResult>;
  tap(params: AndroidDeviceTapParams, metadata?: Metadata): Promise<AndroidDeviceTapResult>;
  drag(params: AndroidDeviceDragParams, metadata?: Metadata): Promise<AndroidDeviceDragResult>;
  fling(params: AndroidDeviceFlingParams, metadata?: Metadata): Promise<AndroidDeviceFlingResult>;
  longTap(params: AndroidDeviceLongTapParams, metadata?: Metadata): Promise<AndroidDeviceLongTapResult>;
  pinchClose(params: AndroidDevicePinchCloseParams, metadata?: Metadata): Promise<AndroidDevicePinchCloseResult>;
  pinchOpen(params: AndroidDevicePinchOpenParams, metadata?: Metadata): Promise<AndroidDevicePinchOpenResult>;
  scroll(params: AndroidDeviceScrollParams, metadata?: Metadata): Promise<AndroidDeviceScrollResult>;
  swipe(params: AndroidDeviceSwipeParams, metadata?: Metadata): Promise<AndroidDeviceSwipeResult>;
  info(params: AndroidDeviceInfoParams, metadata?: Metadata): Promise<AndroidDeviceInfoResult>;
  tree(params?: AndroidDeviceTreeParams, metadata?: Metadata): Promise<AndroidDeviceTreeResult>;
  screenshot(params?: AndroidDeviceScreenshotParams, metadata?: Metadata): Promise<AndroidDeviceScreenshotResult>;
  inputType(params: AndroidDeviceInputTypeParams, metadata?: Metadata): Promise<AndroidDeviceInputTypeResult>;
  inputPress(params: AndroidDeviceInputPressParams, metadata?: Metadata): Promise<AndroidDeviceInputPressResult>;
  inputTap(params: AndroidDeviceInputTapParams, metadata?: Metadata): Promise<AndroidDeviceInputTapResult>;
  inputSwipe(params: AndroidDeviceInputSwipeParams, metadata?: Metadata): Promise<AndroidDeviceInputSwipeResult>;
  inputDrag(params: AndroidDeviceInputDragParams, metadata?: Metadata): Promise<AndroidDeviceInputDragResult>;
  launchBrowser(params: AndroidDeviceLaunchBrowserParams, metadata?: Metadata): Promise<AndroidDeviceLaunchBrowserResult>;
  open(params: AndroidDeviceOpenParams, metadata?: Metadata): Promise<AndroidDeviceOpenResult>;
  shell(params: AndroidDeviceShellParams, metadata?: Metadata): Promise<AndroidDeviceShellResult>;
  installApk(params: AndroidDeviceInstallApkParams, metadata?: Metadata): Promise<AndroidDeviceInstallApkResult>;
  push(params: AndroidDevicePushParams, metadata?: Metadata): Promise<AndroidDevicePushResult>;
  setDefaultTimeoutNoReply(params: AndroidDeviceSetDefaultTimeoutNoReplyParams, metadata?: Metadata): Promise<AndroidDeviceSetDefaultTimeoutNoReplyResult>;
  connectToWebView(params: AndroidDeviceConnectToWebViewParams, metadata?: Metadata): Promise<AndroidDeviceConnectToWebViewResult>;
  close(params?: AndroidDeviceCloseParams, metadata?: Metadata): Promise<AndroidDeviceCloseResult>;
}
export type AndroidDeviceWebViewAddedEvent = {
  webView: AndroidWebView,
};
export type AndroidDeviceWebViewRemovedEvent = {
  pid: number,
};
export type AndroidDeviceWaitParams = {
  selector: AndroidSelector,
  state?: 'gone',
  timeout?: number,
};
export type AndroidDeviceWaitOptions = {
  state?: 'gone',
  timeout?: number,
};
export type AndroidDeviceWaitResult = void;
export type AndroidDeviceFillParams = {
  selector: AndroidSelector,
  text: string,
  timeout?: number,
};
export type AndroidDeviceFillOptions = {
  timeout?: number,
};
export type AndroidDeviceFillResult = void;
export type AndroidDeviceTapParams = {
  selector: AndroidSelector,
  duration?: number,
  timeout?: number,
};
export type AndroidDeviceTapOptions = {
  duration?: number,
  timeout?: number,
};
export type AndroidDeviceTapResult = void;
export type AndroidDeviceDragParams = {
  selector: AndroidSelector,
  dest: Point,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceDragOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceDragResult = void;
export type AndroidDeviceFlingParams = {
  selector: AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceFlingOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceFlingResult = void;
export type AndroidDeviceLongTapParams = {
  selector: AndroidSelector,
  timeout?: number,
};
export type AndroidDeviceLongTapOptions = {
  timeout?: number,
};
export type AndroidDeviceLongTapResult = void;
export type AndroidDevicePinchCloseParams = {
  selector: AndroidSelector,
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchCloseOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchCloseResult = void;
export type AndroidDevicePinchOpenParams = {
  selector: AndroidSelector,
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchOpenOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDevicePinchOpenResult = void;
export type AndroidDeviceScrollParams = {
  selector: AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceScrollOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceScrollResult = void;
export type AndroidDeviceSwipeParams = {
  selector: AndroidSelector,
  direction: 'up' | 'down' | 'left' | 'right',
  percent: number,
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceSwipeOptions = {
  speed?: number,
  timeout?: number,
};
export type AndroidDeviceSwipeResult = void;
export type AndroidDeviceInfoParams = {
  selector: AndroidSelector,
};
export type AndroidDeviceInfoOptions = {

};
export type AndroidDeviceInfoResult = {
  info: AndroidElementInfo,
};
export type AndroidDeviceTreeParams = {};
export type AndroidDeviceTreeOptions = {};
export type AndroidDeviceTreeResult = {
  tree: AndroidElementInfo,
};
export type AndroidDeviceScreenshotParams = {};
export type AndroidDeviceScreenshotOptions = {};
export type AndroidDeviceScreenshotResult = {
  binary: Binary,
};
export type AndroidDeviceInputTypeParams = {
  text: string,
};
export type AndroidDeviceInputTypeOptions = {

};
export type AndroidDeviceInputTypeResult = void;
export type AndroidDeviceInputPressParams = {
  key: string,
};
export type AndroidDeviceInputPressOptions = {

};
export type AndroidDeviceInputPressResult = void;
export type AndroidDeviceInputTapParams = {
  point: Point,
};
export type AndroidDeviceInputTapOptions = {

};
export type AndroidDeviceInputTapResult = void;
export type AndroidDeviceInputSwipeParams = {
  segments: Point[],
  steps: number,
};
export type AndroidDeviceInputSwipeOptions = {

};
export type AndroidDeviceInputSwipeResult = void;
export type AndroidDeviceInputDragParams = {
  from: Point,
  to: Point,
  steps: number,
};
export type AndroidDeviceInputDragOptions = {

};
export type AndroidDeviceInputDragResult = void;
export type AndroidDeviceLaunchBrowserParams = {
  packageName?: string,
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceResourcesPath?: string,
  _tracePath?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
};
export type AndroidDeviceLaunchBrowserOptions = {
  packageName?: string,
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: NameValue[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
  _traceResourcesPath?: string,
  _tracePath?: string,
  recordVideo?: {
    dir: string,
    size?: {
      width: number,
      height: number,
    },
  },
  recordHar?: {
    omitContent?: boolean,
    path: string,
  },
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
};
export type AndroidDeviceLaunchBrowserResult = {
  context: BrowserContextChannel,
};
export type AndroidDeviceOpenParams = {
  command: string,
};
export type AndroidDeviceOpenOptions = {

};
export type AndroidDeviceOpenResult = {
  socket: AndroidSocketChannel,
};
export type AndroidDeviceShellParams = {
  command: string,
};
export type AndroidDeviceShellOptions = {

};
export type AndroidDeviceShellResult = {
  result: Binary,
};
export type AndroidDeviceInstallApkParams = {
  file: Binary,
  args?: string[],
};
export type AndroidDeviceInstallApkOptions = {
  args?: string[],
};
export type AndroidDeviceInstallApkResult = void;
export type AndroidDevicePushParams = {
  file: Binary,
  path: string,
  mode?: number,
};
export type AndroidDevicePushOptions = {
  mode?: number,
};
export type AndroidDevicePushResult = void;
export type AndroidDeviceSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type AndroidDeviceSetDefaultTimeoutNoReplyOptions = {

};
export type AndroidDeviceSetDefaultTimeoutNoReplyResult = void;
export type AndroidDeviceConnectToWebViewParams = {
  pid: number,
};
export type AndroidDeviceConnectToWebViewOptions = {

};
export type AndroidDeviceConnectToWebViewResult = {
  context: BrowserContextChannel,
};
export type AndroidDeviceCloseParams = {};
export type AndroidDeviceCloseOptions = {};
export type AndroidDeviceCloseResult = void;

export type AndroidWebView = {
  pid: number,
  pkg: string,
};

export type AndroidSelector = {
  checkable?: boolean,
  checked?: boolean,
  clazz?: string,
  clickable?: boolean,
  depth?: number,
  desc?: string,
  enabled?: boolean,
  focusable?: boolean,
  focused?: boolean,
  hasChild?: {
    selector: AndroidSelector,
  },
  hasDescendant?: {
    selector: AndroidSelector,
    maxDepth?: number,
  },
  longClickable?: boolean,
  pkg?: string,
  res?: string,
  scrollable?: boolean,
  selected?: boolean,
  text?: string,
};

export type AndroidElementInfo = {
  children?: AndroidElementInfo[],
  clazz: string,
  desc: string,
  res: string,
  pkg: string,
  text: string,
  bounds: Rect,
  checkable: boolean,
  checked: boolean,
  clickable: boolean,
  enabled: boolean,
  focusable: boolean,
  focused: boolean,
  longClickable: boolean,
  scrollable: boolean,
  selected: boolean,
};
